%%
headers
/*
 * Copyright (c) 2009 Mark Lee <libdesktop-agnostic@lazymalevolence.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
*/

#ifdef HAVE_BUILD_CONFIG_H
#include "build-config.h"
#endif
#include <pygobject.h>
#include <libdesktop-agnostic/config.h>
%%
modulename desktopagnostic.config
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob *_get_type
%%
override desktop_agnostic_config_client_get_value kwargs
static PyObject *
_wrap_desktop_agnostic_config_client_get_value (PyGObject *self, PyObject *args,
                                                PyObject *kwargs)
{
  static char *kwlist[] = { "group", "key", NULL };
  char *group, *key;
  PyObject *ret;
  GError *error = NULL;
  GValue value = { 0, };

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "ss:desktopagnostic.config.Client.get_value",
                                    kwlist, &group, &key))
  {
    return NULL;
  }

  value = desktop_agnostic_config_client_get_value (DESKTOP_AGNOSTIC_CONFIG_CLIENT (self->obj),
                                                    group, key, &error);

  if (pyg_error_check (&error))
  {
    return NULL;
  }

  ret = pyg_value_as_pyobject (&value, TRUE);
  g_value_unset (&value);

  return ret;
}
%%
override desktop_agnostic_config_client_set_value kwargs
static PyObject *
_wrap_desktop_agnostic_config_client_set_value (PyGObject *self, PyObject *args,
                                                PyObject *kwargs)
{
  static char *kwlist[] = { "group", "key", "value", NULL };
  char *group, *key;
  PyObject *obj;
  GType type;
  GValue value = { 0, };
  GError *error = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "ssO:desktopagnostic.config.Client.set_value",
                                    kwlist, &group, &key, &obj))
  {
    return NULL;
  }

  // FIXME: special case sequences and init the value to G_TYPE_VALUE_ARRAY
  type = pyg_type_from_object ((PyObject *)obj->ob_type);
  if (type == G_TYPE_INVALID)
  {
    return NULL;
  }

  g_value_init (&value, type);

  if (pyg_value_from_pyobject (&value, obj) != 0)
  {
    return NULL;
  }

  desktop_agnostic_config_client_set_value (DESKTOP_AGNOSTIC_CONFIG_CLIENT (self->obj),
                                            group, key, &value, &error);

  if (pyg_error_check (&error))
  {
    return NULL;
  }

  Py_INCREF (Py_None);
  return Py_None;
}
%%
override desktop_agnostic_config_client_get_list kwargs
static PyObject *
_wrap_desktop_agnostic_config_client_get_list (PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
  static char *kwlist[] = { "group", "key", NULL };
  char *group, *key;
  PyObject *ret;
  guint i;
  GError *error = NULL;
  GValueArray *array;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "ss:desktopagnostic.config.Client.get_list",
                                    kwlist, &group, &key))
  {
    return NULL;
  }

  array = desktop_agnostic_config_client_get_list (DESKTOP_AGNOSTIC_CONFIG_CLIENT (self->obj),
                                                   group, key, &error);

  if (pyg_error_check (&error))
  {
    return NULL;
  }

  ret = PyList_New (array->n_values);
  for (i = 0; i < array->n_values; i++)
  {
    PyList_SET_ITEM (ret, i, pyg_value_as_pyobject (array->values + i, TRUE));
  }

  g_value_array_free (array);

  return ret;
}
%%
override desktop_agnostic_config_client_set_list kwargs
static PyObject *
_wrap_desktop_agnostic_config_client_set_list (PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
  static char *kwlist[] = { "group", "key", "list", NULL };
  char *group, *key;
  PyObject *obj;
  GValue value = { 0, };
  GValueArray *array;
  GError *error = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "ssO!:desktopagnostic.config.Client.set_list",
                                    kwlist, &group, &key, &PyList_Type, &obj))
  {
    return NULL;
  }

  g_value_init (&value, G_TYPE_VALUE_ARRAY);
  if (pyg_value_from_pyobject (&value, obj) != 0)
  {
    return NULL;
  }

  array = g_value_get_boxed (&value);

  desktop_agnostic_config_client_set_list (DESKTOP_AGNOSTIC_CONFIG_CLIENT (self->obj),
                                           group, key, array, &error);

  g_value_unset (&value);

  if (pyg_error_check (&error))
  {
    return NULL;
  }

  Py_INCREF (Py_None);
  return Py_None;
}
%%
override desktop_agnostic_config_client_notify_add kwargs
void
pydesktopagnostic_config_client_notify_add (const gchar* group,
                                            const gchar* key,
                                            const GValue* value,
                                            gpointer user_data)
{
  PyObject *tuple;
  PyObject *func;
  PyObject *userdata = NULL;
  PyObject *py_value;
  PyObject *ret;
  PyGILState_STATE state;

  tuple = (PyObject*) user_data;

  state = pyg_gil_state_ensure ();

  g_assert (PyTuple_Check (tuple));
  func = PyTuple_GetItem (tuple, 0);

  if (PyTuple_Size (tuple) > 1)
  {
    userdata = PyTuple_GetItem (tuple, 1);
  }

  py_value = pyg_value_as_pyobject (value, TRUE);

  if (userdata)
  {
    ret = PyObject_CallFunction (func, "ssOO", group, key, py_value, userdata);
  }
  else
  {
    ret = PyObject_CallFunction (func, "ssO", group, key, py_value);
  }

  Py_DECREF (py_value);

  if (ret == NULL)
  {
    PyErr_Print ();
  }
  else
  {
    Py_DECREF (ret);
  }

  pyg_gil_state_release (state);
}

static PyObject *
_wrap_desktop_agnostic_config_client_notify_add (PyGObject *self,
                                                 PyObject *args,
                                                 PyObject *kwargs)
{
  static char *kwlist[] = { "group", "key", "func", "user_data", NULL };
  gchar *group;
  gchar *key;
  PyObject *callback;
  PyObject *extra = NULL;
  PyObject *data;
  GError *error = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "ssO|O:desktopagnostic.config.Client.notify_add",
                                    kwlist, &group, &key, &callback, &extra))
  {
    return NULL;
  }

  if (!PyCallable_Check (callback))
  {
    PyErr_SetString (PyExc_TypeError, "Third argument not callable");
    return NULL;
  }

  // FIXME: to support notify_remove we need to save these 'data' vars
  //        to a global list/array

  if (extra)
  {
    data = Py_BuildValue ("(OO)", callback, extra);
  }
  else
  {
    data = Py_BuildValue ("(O)", callback);
  }

  desktop_agnostic_config_client_notify_add (DESKTOP_AGNOSTIC_CONFIG_CLIENT (self->obj),
                                             group, key,
                                             pydesktopagnostic_config_client_notify_add,
                                             data, &error);

  if (pyg_error_check (&error))
  {
    return NULL;
  }

  Py_INCREF (Py_None);
  return Py_None;
}
